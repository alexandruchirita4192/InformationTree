using System;
using System.Drawing;
using System.Windows.Forms;
using InformationTree.Domain;
using InformationTree.Domain.Entities;
using InformationTree.Domain.Services;

namespace InformationTree.Render.WinForms.Extensions
{
    public static class TreeNodeExtensions
    {
        public static void ExpandParents(this TreeNode node)
        {
            if (node == null)
                return;

            var parent = node.Parent;
            if (parent != null)
            {
                parent.Expand();
                ExpandParents(parent);
            }
        }

        // TODO: Work with new methods for TreeNodeData.
        // This copy methods all allow working with TreeNode and TreeNodeCollection, but working with these is not recommended.
        // TreeNode should be able to be generated by TreeNodeData.
        public static void Copy(
            this TreeNode destination,
            TreeNode source,
            ITreeNodeDataCachingService treeNodeDataCachingService,
            bool includeChildren = true,
            int? filterHigherThan = null,
            int? filterLowerThan = null,
            CopyNodeFilterType filterType = CopyNodeFilterType.NoFilter)
        {
            if (source == null)
                throw new ArgumentNullException(nameof(source));
            if (destination == null)
                throw new ArgumentNullException(nameof(destination));
            if (destination.Nodes == null)
                throw new ArgumentNullException(nameof(destination.Nodes));
            if (treeNodeDataCachingService == null)
                throw new ArgumentNullException(nameof(treeNodeDataCachingService));

            var tagData = source.ToTreeNodeData(treeNodeDataCachingService);

            // Filter nodes by added number or urgency depending on the type
            if ((filterType == CopyNodeFilterType.FilterByAddedNumber) && (tagData.AddedNumber >= filterLowerThan) || (tagData.AddedNumber < filterHigherThan))
                return;
            else if ((filterType == CopyNodeFilterType.FilterByUrgency) && (tagData.Urgency >= filterLowerThan) || (tagData.Urgency < filterHigherThan))
                return;

            var toTag = destination.ToTreeNodeData(treeNodeDataCachingService);
            toTag.Copy(tagData);

            // Shallow copy of the used properties only
            destination.Text = source.Text;
            destination.Name = source.Name;
            destination.ToolTipText = source.ToolTipText;

            var font = source.NodeFont;
            destination.NodeFont = font != null ? new Font(font.FontFamily, font.SizeInPoints, font.Style) : WinFormsConstants.FontDefaults.DefaultFont;

            destination.ForeColor = source.ForeColor.IsEmpty ? Constants.Colors.DefaultForeGroundColor : source.ForeColor;
            destination.BackColor = source.BackColor.IsEmpty ? Constants.Colors.DefaultBackGroundColor : source.BackColor;

            if (includeChildren)
            {
                foreach (TreeNode node in source.Nodes)
                    destination.Nodes.Copy(node, treeNodeDataCachingService, filterHigherThan, filterLowerThan, filterType);

            }
        }

        // TODO: Create an adapter with that, to change from TreeNode to TreeNodeData and vice versa and remove the dependency requirement in extension parameters
        public static TreeNodeData ToTreeNodeData(this TreeNode treeNode, ITreeNodeDataCachingService treeNodeDataCachingService)
        {
            if (treeNode == null)
                throw new ArgumentNullException(nameof(treeNode));
            if (treeNodeDataCachingService == null)
                throw new ArgumentNullException(nameof(treeNodeDataCachingService));

            TreeNodeData treeNodeData;
            var treeNodeIdentifier = treeNode.Tag as Guid?;

            if (treeNodeIdentifier == null)
                (treeNodeData, treeNodeIdentifier) = treeNode.CreateTreeNodeDataAndAddToCache(treeNodeDataCachingService);
            else
            {
                treeNodeData = treeNodeDataCachingService.GetFromCache(treeNodeIdentifier.Value);
                if (treeNodeData == null)
                    (treeNodeData, treeNodeIdentifier) = treeNode.CreateTreeNodeDataAndAddToCache(treeNodeDataCachingService);
            }
            treeNode.Tag = treeNodeData != null ? treeNodeIdentifier : null;

            // Children might already be in place because the cache gives a reference to a TreeNodeData with it's children,
            // but here children are refreshed anyway
            treeNodeData.Children.Clear();

            foreach (TreeNode childTreeNode in treeNode.Nodes)
            {
                var childTreeNodeData = childTreeNode.ToTreeNodeData(treeNodeDataCachingService);
                treeNodeData.Children.Add(childTreeNodeData);
            }

            return treeNodeData;
        }

        private static (TreeNodeData, Guid) CreateTreeNodeDataAndAddToCache(this TreeNode treeNode, ITreeNodeDataCachingService treeNodeDataCachingService)
        {
            var treeNodeData = CreateNewTreeNodeData(treeNode);
            var newGuid = treeNodeDataCachingService.AddToCache(treeNodeData);
            return (treeNodeData, newGuid);
        }

        private static TreeNodeData CreateNewTreeNodeData(TreeNode treeNode)
        {
            var fontFamily = treeNode.NodeFont?.FontFamily ?? WinFormsConstants.FontDefaults.DefaultFontFamily;

            return new TreeNodeData
            {
                Text = treeNode.Text,
                Name = treeNode.Name,
                NodeFont = new TreeNodeFont
                {
                    Bold = treeNode.NodeFont?.Bold ?? false,
                    Italic = treeNode.NodeFont?.Italic ?? false,
                    Strikeout = treeNode.NodeFont?.Strikeout ?? false,
                    Underline = treeNode.NodeFont?.Underline ?? false,
                    Size = treeNode.NodeFont?.Size ?? WinFormsConstants.FontDefaults.DefaultFontSize,
                    FontFamilyName = fontFamily?.Name
                },
                AddedDate = DateTime.Now,
                LastChangeDate = DateTime.Now
            };
        }
    }
}
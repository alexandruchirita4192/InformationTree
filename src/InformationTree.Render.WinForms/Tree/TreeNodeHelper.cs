using System;
using System.Collections.Generic;
using System.Drawing;
using System.Windows.Forms;
using InformationTree.Domain;
using InformationTree.Domain.Entities;
using InformationTree.Domain.Extensions;
using InformationTree.Domain.Services;
using InformationTree.Render.WinForms;
using InformationTree.Render.WinForms.Extensions;

namespace InformationTree.Tree
{
    // TODO: Change from static to service (facade hiding subsystem complexity with an interface) with instance and get services in constructor and remove them from static methods
    [Obsolete("Break into many classes with many purposes")]
    public static class TreeNodeHelper
    {
        // TODO: Maybe use a mediator like MediatR to handle all events, commands, etc. (each of those could be a separate command handler class)

        #region CopyNode, CopyNodes

        // TODO: Work with new methods for TreeNodeData.
        // This copy methods all allow working with TreeNode and TreeNodeCollection, but working with these is not recommended.
        // TreeNode should be able to be generated by TreeNodeData.
        public static void CopyNodes(
            TreeNodeCollection to,
            TreeNodeCollection from,
            ITreeNodeDataCachingService treeNodeDataCachingService,
            int? filterHigherThan = null,
            int? filterLowerThan = null,
            CopyNodeFilterType filterType = CopyNodeFilterType.NoFilter)
        {
            if (from == null)
                throw new ArgumentNullException(nameof(from));
            if (to == null)
                throw new ArgumentNullException(nameof(to));
            if (treeNodeDataCachingService == null)
                throw new ArgumentNullException(nameof(treeNodeDataCachingService));

            foreach (TreeNode node in from)
                CopyNode(to, node, treeNodeDataCachingService, filterHigherThan, filterLowerThan, filterType);
        }

        public static void CopyNode(
            TreeNodeCollection to,
            TreeNode from,
            ITreeNodeDataCachingService treeNodeDataCachingService,
            int? filterHigherThan = null,
            int? filterLowerThan = null,
            CopyNodeFilterType filterType = CopyNodeFilterType.NoFilter)
        {
            if (from == null)
                throw new ArgumentNullException(nameof(from));
            if (to == null)
                throw new ArgumentNullException(nameof(to));
            if (treeNodeDataCachingService == null)
                throw new ArgumentNullException(nameof(treeNodeDataCachingService));

            var node = new TreeNode();
            CopyNode(node, from, treeNodeDataCachingService, filterHigherThan, filterLowerThan, filterType);

            if ((filterLowerThan == null && filterHigherThan == null) || (filterLowerThan != null && filterHigherThan != null))
                to.Add(node);
        }

        public static void CopyNode(
            TreeNode to,
            TreeNode from,
            ITreeNodeDataCachingService treeNodeDataCachingService,
            int? filterHigherThan = null,
            int? filterLowerThan = null,
            CopyNodeFilterType filterType = CopyNodeFilterType.NoFilter)
        {
            if (from == null)
                throw new ArgumentNullException(nameof(from));
            if (to == null)
                throw new ArgumentNullException(nameof(to));
            if (to.Nodes == null)
                throw new ArgumentNullException(nameof(to.Nodes));
            if (treeNodeDataCachingService == null)
                throw new ArgumentNullException(nameof(treeNodeDataCachingService));

            var tagData = from.ToTreeNodeData(treeNodeDataCachingService);

            // Filter nodes by added number or urgency depending on the type
            if ((filterType == CopyNodeFilterType.FilterByAddedNumber) && (tagData.AddedNumber >= filterLowerThan) || (tagData.AddedNumber < filterHigherThan))
                return;
            else if ((filterType == CopyNodeFilterType.FilterByUrgency) && (tagData.Urgency >= filterLowerThan) || (tagData.Urgency < filterHigherThan))
                return;

            var toTag = to.ToTreeNodeData(treeNodeDataCachingService);
            toTag.Copy(tagData);

            to.Text = from.Text;
            to.Name = from.Name;

            var font = from.NodeFont;
            to.NodeFont = font != null ? new Font(font.FontFamily, font.SizeInPoints, font.Style) : WinFormsConstants.FontDefaults.DefaultFont;

            to.ForeColor = from.ForeColor.IsEmpty ? Constants.Colors.DefaultForeGroundColor : from.ForeColor;
            to.BackColor = from.BackColor.IsEmpty ? Constants.Colors.DefaultBackGroundColor : from.BackColor;

            foreach (TreeNode node in from.Nodes)
                CopyNode(to.Nodes, node, treeNodeDataCachingService, filterHigherThan, filterLowerThan, filterType);
        }

        #endregion CopyNode, CopyNodes

        #region Node search

        public static void ExpandParents(TreeNode node)
        {
            if (node == null)
                return;

            var parent = node.Parent;
            if (parent != null)
            {
                parent.Expand();
                ExpandParents(parent);
            }
        }

        public static void SetStyleForSearch(TreeNodeCollection nodes, string text, ITreeNodeDataCachingService treeNodeDataCachingService)
        {
            if (nodes == null)
                throw new ArgumentNullException(nameof(nodes));
            if (text.IsEmpty())
                throw new ArgumentNullException(nameof(text));

            text = text.ToLower();
            if (nodes.Count > 0)
            {
                foreach (TreeNode node in nodes)
                {
                    var nodeTagData = node.ToTreeNodeData(treeNodeDataCachingService);
                    var nodeData = nodeTagData != null && !string.IsNullOrEmpty(nodeTagData.Data) ? nodeTagData.Data : null;
                    var foundCondition = (node.Text != null && node.Text.ToLower().Split('[')[0].Contains(text))
                        || (nodeData != null && nodeData.ToLower().Contains(text));

                    if (foundCondition
                        && (node.BackColor != Constants.Colors.BackGroundColorSearch
                        || node.ForeColor != Constants.Colors.ForeGroundColorSearch))
                    {
                        node.BackColor = Constants.Colors.BackGroundColorSearch;
                        node.ForeColor = Constants.Colors.ForeGroundColorSearch;
                        node.Expand();

                        ExpandParents(node);
                    }

                    if (node.Nodes != null && node.Nodes.Count > 0)
                        SetStyleForSearch(node.Nodes, text, treeNodeDataCachingService);
                }
            }
        }

        public static string[] GenerateStringGraphicsLinesFromTree(TreeView tvTaskList)
        {
            if (tvTaskList == null)
                throw new ArgumentNullException(nameof(tvTaskList));

            List<string> lines = new List<string>();

            foreach (TreeNode task in tvTaskList.Nodes)
                lines.Add(task.Text);

            return lines.ToArray();
        }

        public static void ClearStyleAdded(TreeNodeCollection col)
        {
            if (col == null)
                throw new ArgumentNullException(nameof(col));

            if (col.Count > 0)
            {
                foreach (TreeNode node in col)
                {
                    if (node.BackColor != Constants.Colors.DefaultBackGroundColor)
                        node.BackColor = Constants.Colors.DefaultBackGroundColor;

                    if (node.ForeColor != Constants.Colors.DefaultForeGroundColor)
                        node.ForeColor = Constants.Colors.DefaultForeGroundColor;

                    if (node.Nodes.Count > 0)
                        ClearStyleAdded(node.Nodes);
                }
            }
        }

        #endregion Node search
    }
}